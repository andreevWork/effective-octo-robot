module Compose.Compose ( compose2 ) where

compose2 :: (c -> d) -> (a -> b -> c) -> a -> b -> d

-- 1 Простой вариант
--compose2 f g x y = f (g x y)




-- 2 Убираем второй аргумент y
-- g x -> функция g от двух аргументов вызывается на 1 и возвращает функцию от 1, оставшегося аргумента.
-- Поэтому g :: a -> b -> c превратилось в g x == g' :: b -> c
-- Следовательно можно применить обычную композицую, поскольку имеем две функции от одного аргумента
-- f . g x == f . g' - на выходе получаем функцию от одного аргумента, а именно удаленного "y"
--compose2 f g x = f . g x





-- 3 Убираем первый аругмент x

{-

Если взять предидущий вариант:
compose2 f g x = f . g x

и просто убрать x:
compose2 f g = f . g

Само собой все сломается поскольку результат композиции принимает 1 аргумент и следовательно:
(f . g) x y
обработает только x, а следовательно "g" вернет не результат а функцию, а функция f упадет, поскольку f принимает
простой аргумент а не функцию.

Значит необходимо сделать так, чтобы f стала принимать не просто аргумент, а функцию, которую возвращает g
то есть из
(f . g) x y

надо сделать что-то
(f' . g) x y

где f' имеет тип (a -> b) -> a -> c
то есть принимает функцию от 1 аргумента, то что осталось от "g"; принимает простой аргумент - это y; и возвращет результат:
(f' . g) x y == ((\fn a -> f (fn a)) . g) x y

-}
--compose2 f g = ((\fn a -> f (fn a)) . g)






-- 4 Упрощаем

{-
Анонимная функция ее можно сильно упростить
(\fn a -> f (fn a))

Видно что функция чем-то напоминает определение копмозиции
f . g = \x -> f (g x)

Только в нашем случае принимается 1 функция и аргумент, а не 2 функции и аргумент как в композиции.
Очевидно что можно просто частично применить композицию:
(\fn a -> f (fn a)) == (f.) -  не забывать про то, что есть разница с какой стороны от (.) ставить аргумент
главное
-}

--compose2 f g = (f.) . g




-- 5 Убираем еще один аргумент

--compose2 f = (.) (f.)







-- 6 В итоге безточечный стиль

--compose2 f = (.) (f.)
--compose2 f = (.) ((.) f)
compose2 = (.) . (.)